{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/FNS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface FNS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address indexed owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\n\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\n\n    function setSubnodeResolver(bytes32 node, bytes32 label, address resolver) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IMulticallable {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(bytes32, bytes[] calldata data) external returns (bytes[] memory results);\n}\n"
    },
    "contracts/libs/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\npragma solidity >=0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/libs/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity >=0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"./interfaces/IMulticallable.sol\";\nimport \"./libs/ERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, ERC165 {\n    function _multicall(bytes32 nodehash, bytes[] calldata data) internal returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(txNamehash == nodehash, \"multicall: All records must have a matching namehash\");\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as RegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(bytes32 nodehash, bytes[] calldata data) external returns (bytes[] memory results) {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(bytes[] calldata data) public override returns (bytes[] memory results) {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/PublicResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"./interfaces/FNS.sol\";\nimport \"./resolvers/AddressResolver.sol\";\nimport \"./resolvers/ContentHashResolver.sol\";\nimport \"./resolvers/NameResolver.sol\";\nimport \"./resolvers/TextResolver.sol\";\nimport \"./Multicallable.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is Multicallable, AddressResolver, ContentHashResolver, NameResolver, TextResolver {\n    FNS immutable fns;\n    address immutable trustedRegistrarController;\n    address immutable trustedReverseRegistrar;\n\n    /**\n     * A mapping of operators. An address that is authorised for an address\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (owner, operator) => approved\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    constructor(\n        FNS _fns,\n        address _trustedRegistrarController,\n        address _trustedReverseRegistrar\n    ) {\n        fns = _fns;\n        trustedRegistrarController = _trustedRegistrarController;\n        trustedReverseRegistrar = _trustedReverseRegistrar;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        require(msg.sender != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\n        if (msg.sender == trustedRegistrarController || msg.sender == trustedReverseRegistrar) {\n            return true;\n        }\n        address owner = fns.owner(node);\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        override(Multicallable, AddressResolver, ContentHashResolver, NameResolver, TextResolver)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"./libs/ERC165.sol\";\nimport \"./resolvers/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165, IVersionableResolver {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /**\n     * Increments the record version associated with an FNS node.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     */\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(IVersionableResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"../ResolverBase.sol\";\nimport \"./IAddressResolver.sol\";\n\nabstract contract AddressResolver is IAddressResolver, ResolverBase {\n    // https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n    uint256 private constant COIN_TYPE_FIL = 461;\n\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /**\n     * Sets the address associated with an FNS node.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(bytes32 node, address a) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_FIL, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an FNS node.\n     * @param node The FNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view virtual returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_FIL);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    /**\n     * Sets the address associated with an FNS node.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param coinType The coin type of the address.\n     * @param a The address to set.\n     */\n    function setAddr(bytes32 node, uint256 coinType, bytes memory a) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\n    }\n\n    /**\n     * Sets the addresses associated with FNS node.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param coinTypes The coin types of the addresses.\n     * @param addrs The addresses to set.\n     */\n    function setAddrs(bytes32 node, uint256[] calldata coinTypes, bytes[] calldata addrs)\n        public\n        virtual\n        authorised(node)\n    {\n        uint256 count = coinTypes.length;\n        require(addrs.length == count, \"length\");\n        for (uint256 i = 0; i < count; i++) {\n            uint256 coinType = coinTypes[i];\n            versionable_addresses[recordVersions[node]][node][coinType] = addrs[i];\n            emit AddressChanged(node, coinType, addrs[i]);\n        }\n    }\n\n    function addr(bytes32 node, uint256 coinType) public view virtual override returns (bytes memory) {\n        return versionable_addresses[recordVersions[node]][node][coinType];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(IAddressResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(bytes memory b) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/resolvers/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"../ResolverBase.sol\";\nimport \"./IContentHashResolver.sol\";\n\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\n\n    /**\n     * Sets the contenthash associated with an FNS node.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(bytes32 node, bytes calldata hash) external virtual authorised(node) {\n        versionable_hashes[recordVersions[node]][node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an FNS node.\n     * @param node The FNS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view virtual override returns (bytes memory) {\n        return versionable_hashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\n/**\n * Interface for the new (multicoin) address function.\n */\ninterface IAddressResolver {\n    event AddressChanged(bytes32 indexed node, uint256 coinType, bytes newAddress);\n\n    function addr(bytes32 node) external view returns (address payable);\n\n    function addr(bytes32 node, uint256 coinType) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an FNS node.\n     * @param node The FNS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an FNS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The FNS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface ITextResolver {\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value);\n\n    /**\n     * Returns the text data associated with an FNS node and key.\n     * @param node The FNS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
    },
    "contracts/resolvers/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"../ResolverBase.sol\";\nimport \"./INameResolver.sol\";\n\nabstract contract NameResolver is INameResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n\n    /**\n     * Sets the name associated with an FNS node, for reverse records.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     */\n    function setName(bytes32 node, string calldata newName) external virtual authorised(node) {\n        versionable_names[recordVersions[node]][node] = newName;\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an FNS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The FNS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view virtual override returns (string memory) {\n        return versionable_names[recordVersions[node]][node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n\n    /**\n     * Sets the text data associated with an FNS node and key.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(bytes32 node, string calldata key, string calldata value) external virtual authorised(node) {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Sets the text data associated with an FNS node and keys.\n     * May only be called by the owner of that node in the FNS registry.\n     * @param node The node to update.\n     * @param keys The keys to set.\n     * @param values The text data value to set.\n     */\n    function setTexts(bytes32 node, string[] calldata keys, string[] calldata values)\n        external\n        virtual\n        authorised(node)\n    {\n        uint256 count = keys.length;\n        require(count == values.length, \"length\");\n        for (uint256 i = 0; i < count; i++) {\n            versionable_texts[recordVersions[node]][node][keys[i]] = values[i];\n            emit TextChanged(node, keys[i], keys[i], values[i]);\n        }\n    }\n\n    /**\n     * Returns the text data associated with an FNS node and key.\n     * @param node The FNS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) external view virtual override returns (string memory) {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}